asHook: true
auth:
  register: true
clickhouse:
  clickhouse:
    configmap:
      builtin_dictionaries_reload_interval: "3600"
      compression:
        cases:
        - method: zstd
          min_part_size: "10000000000"
          min_part_size_ratio: "0.01"
        enabled: false
      default_session_timeout: "60"
      disable_internal_dns_cache: "1"
      enabled: true
      graphite:
        config:
        - asynchronous_metrics: true
          events: true
          events_cumulative: true
          interval: "60"
          metrics: true
          root_path: one_min
          timeout: "0.1"
        enabled: false
      keep_alive_timeout: "3"
      logger:
        count: "10"
        level: trace
        path: /var/log/clickhouse-server
        size: 1000M
        stdoutLogsEnabled: false
      mark_cache_size: "5368709120"
      max_concurrent_queries: "100"
      max_connections: "4096"
      max_session_timeout: "3600"
      mlock_executable: false
      profiles:
        enabled: false
        profile:
        - config:
            load_balancing: random
            max_memory_usage: "10000000000"
            use_uncompressed_cache: "0"
          name: default
      quotas:
        enabled: false
        quota:
        - config:
          - duration: "3600"
            errors: "0"
            execution_time: "0"
            queries: "0"
            read_rows: "0"
            result_rows: "0"
          name: default
      remote_servers:
        enabled: true
        internal_replication: true
        replica:
          backup:
            enabled: false
          compression: true
          user: default
      umask: "022"
      uncompressed_cache_size: "8589934592"
      users:
        enabled: false
        user:
        - config:
            networks:
            - ::/0
            password: ""
            profile: default
            quota: default
          name: default
      zookeeper_servers:
        config:
        - hostTemplate: '{{ .Release.Name }}-zookeeper-clickhouse'
          index: clickhouse
          port: "2181"
        enabled: true
        operation_timeout_ms: "10000"
        session_timeout_ms: "30000"
    http_port: "8123"
    image: yandex/clickhouse-server
    imagePullPolicy: IfNotPresent
    imageVersion: 20.8.19.4
    ingress:
      enabled: false
    init:
      image: busybox
      imagePullPolicy: IfNotPresent
      imageVersion: 1.31.0
      resources: {}
    interserver_http_port: "9009"
    livenessProbe:
      enabled: true
      failureThreshold: "3"
      initialDelaySeconds: "30"
      periodSeconds: "30"
      successThreshold: "1"
      timeoutSeconds: "5"
    metrics:
      enabled: false
      image:
        port: 9116
        pullPolicy: IfNotPresent
        registry: docker.io
        repository: f1yegor/clickhouse-exporter
        tag: latest
      podAnnotations:
        prometheus.io/port: "9116"
        prometheus.io/scrape: "true"
      podLabels: {}
      prometheusRule:
        additionalLabels: {}
        enabled: false
        namespace: ""
        rules: []
      service:
        annotations: {}
        labels: {}
        type: ClusterIP
      serviceMonitor:
        enabled: false
        selector:
          prometheus: kube-prometheus
    path: /var/lib/clickhouse
    persistentVolumeClaim:
      dataPersistentVolume:
        accessModes:
        - ReadWriteOnce
        enabled: true
        storage: 30Gi
      enabled: true
      logsPersistentVolume:
        accessModes:
        - ReadWriteOnce
        enabled: false
        storage: 50Gi
    podManagementPolicy: Parallel
    podSecurityContext: {}
    readinessProbe:
      enabled: true
      failureThreshold: "3"
      initialDelaySeconds: "30"
      periodSeconds: "30"
      successThreshold: "1"
      timeoutSeconds: "5"
    replicas: "3"
    resources: {}
    securityContext: {}
    tcp_port: "9000"
    updateStrategy: RollingUpdate
  clusterDomain: cluster.local
  enabled: true
  global: {}
  serviceAccount:
    annotations: {}
    automountServiceAccountToken: true
    enabled: false
    name: clickhouse
  tabix:
    enabled: false
    image: spoonest/clickhouse-tabix-web-client
    imagePullPolicy: IfNotPresent
    imageVersion: stable
    ingress:
      enabled: false
    livenessProbe:
      enabled: true
      failureThreshold: "3"
      initialDelaySeconds: "30"
      periodSeconds: "30"
      successThreshold: "1"
      timeoutSeconds: "5"
    podAnnotations: null
    podLabels: null
    readinessProbe:
      enabled: true
      failureThreshold: "3"
      initialDelaySeconds: "30"
      periodSeconds: "30"
      successThreshold: "1"
      timeoutSeconds: "5"
    replicas: "1"
    resources: {}
    security:
      password: admin
      user: admin
    updateStrategy:
      maxSurge: 3
      maxUnavailable: 1
      type: RollingUpdate
  timezone: UTC
config:
  configYml: {}
  relay: |
    # No YAML relay config given
  sentryConfPy: |
    # No Python Extension Config Given
  snubaSettingsPy: |
    # No Python Extension Config Given
externalClickhouse:
  database: default
  host: clickhouse
  httpPort: 8123
  password: ""
  singleNode: true
  tcpPort: 9000
  username: default
externalKafka:
  port: 9092
externalPostgresql:
  database: sentry
  port: 5432
  username: postgres
externalRedis:
  port: 6379
filestore:
  backend: s3
  filesystem:
    path: /var/lib/sentry/files
    persistence:
      accessMode: ReadWriteOnce
      enabled: false
      existingClaim: ""
      persistentWorkers: false
      size: 10Gi
  gcs: {}
  s3:
    accessKey: GA81CE6RMLAZZ8ETEZCG
    secretKey: AQHUcMN7zu6o9q3MEBFyMG9ud49Np24I3eEKc6ra
    bucketName: sentry
    endpointUrl: https://demo-prd-cluster-storage-minio-oss.service.dc01.local
github: {}
google: {}
hooks:
  dbCheck:
    affinity: {}
    env: []
    image:
      imagePullSecrets: []
    nodeSelector: {}
    podAnnotations: {}
    resources:
      limits:
        memory: 64Mi
      requests:
        cpu: 100m
        memory: 64Mi
    securityContext: {}
  dbInit:
    affinity: {}
    env: []
    nodeSelector: {}
    podAnnotations: {}
    resources:
      limits:
        memory: 2048Mi
      requests:
        cpu: 300m
        memory: 2048Mi
    sidecars: []
    volumes: []
  enabled: true
  removeOnSuccess: true
  snubaInit:
    affinity: {}
    nodeSelector: {}
    podAnnotations: {}
    resources:
      limits:
        cpu: 2000m
        memory: 1Gi
      requests:
        cpu: 700m
        memory: 1Gi
images:
  relay:
    imagePullSecrets: []
  sentry:
    imagePullSecrets: []
  snuba:
    imagePullSecrets: []
  symbolicator:
    imagePullSecrets: []
    tag: 0.5.1
ingress:
  alb:
    httpRedirect: false
  enabled: false
  regexPathStyle: nginx
kafka:
  advertisedListeners: []
  affinity: {}
  allowPlaintextListener: true
  auth:
    clientProtocol: plaintext
    interBrokerProtocol: plaintext
    jaas:
      clientPasswords: []
      clientUsers:
      - user
      interBrokerPassword: ""
      interBrokerUser: admin
    saslInterBrokerMechanism: plain
    saslMechanisms: plain,scram-sha-256,scram-sha-512
    tlsEndpointIdentificationAlgorithm: https
  autoCreateTopicsEnable: true
  clusterDomain: cluster.local
  command:
  - /scripts/setup.sh
  commonAnnotations: {}
  commonLabels: {}
  containerSecurityContext: {}
  customLivenessProbe: {}
  customReadinessProbe: {}
  defaultReplicationFactor: 3
  deleteTopicEnable: false
  enabled: true
  externalAccess:
    autoDiscovery:
      enabled: false
      image:
        pullPolicy: IfNotPresent
        pullSecrets: []
        registry: docker.io
        repository: bitnami/kubectl
        tag: 1.17.13-debian-10-r21
      resources:
        limits: {}
        requests: {}
    enabled: false
    service:
      annotations: {}
      loadBalancerIPs: []
      loadBalancerSourceRanges: []
      nodePorts: []
      port: 9094
      type: LoadBalancer
  externalZookeeper:
    servers: []
  extraDeploy: []
  extraEnvVars: []
  extraVolumeMounts: []
  extraVolumes: []
  global: {}
  heapOpts: -Xmx1024m -Xms1024m
  image:
    debug: false
    pullPolicy: IfNotPresent
    pullSecrets: []
    registry: docker.io
    repository: bitnami/kafka
    tag: 2.6.0-debian-10-r78
  interBrokerListenerName: INTERNAL
  listeners: []
  livenessProbe:
    enabled: true
    initialDelaySeconds: 10
    timeoutSeconds: 5
  logFlushIntervalMessages: 10000
  logFlushIntervalMs: 1000
  logRetentionBytes: _1073741824
  logRetentionCheckIntervalMs: 300000
  logRetentionHours: 168
  logSegmentBytes: _1073741824
  logsDirs: /bitnami/kafka/data
  maxMessageBytes: "50000000"
  metrics:
    jmx:
      config: |-
        jmxUrl: service:jmx:rmi:///jndi/rmi://127.0.0.1:5555/jmxrmi
        lowercaseOutputName: true
        lowercaseOutputLabelNames: true
        ssl: false
        {{- if .Values.metrics.jmx.whitelistObjectNames }}
        whitelistObjectNames: ["{{ join "\",\"" .Values.metrics.jmx.whitelistObjectNames }}"]
        {{- end }}
      enabled: false
      image:
        pullPolicy: IfNotPresent
        pullSecrets: []
        registry: docker.io
        repository: bitnami/jmx-exporter
        tag: 0.14.0-debian-10-r64
      resources:
        limits: {}
        requests: {}
      service:
        annotations:
          prometheus.io/path: /
          prometheus.io/port: '{{ .Values.metrics.jmx.service.port }}'
          prometheus.io/scrape: "true"
        loadBalancerSourceRanges: []
        nodePort: ""
        port: 5556
        type: ClusterIP
      whitelistObjectNames:
      - kafka.controller:*
      - kafka.server:*
      - java.lang:*
      - kafka.network:*
      - kafka.log:*
    kafka:
      enabled: false
      extraFlags: {}
      image:
        pullPolicy: IfNotPresent
        pullSecrets: []
        registry: docker.io
        repository: bitnami/kafka-exporter
        tag: 1.2.0-debian-10-r277
      resources:
        limits: {}
        requests: {}
      service:
        annotations:
          prometheus.io/path: /metrics
          prometheus.io/port: '{{ .Values.metrics.kafka.service.port }}'
          prometheus.io/scrape: "true"
        loadBalancerSourceRanges: []
        nodePort: ""
        port: 9308
        type: ClusterIP
    serviceMonitor:
      enabled: false
  nodeSelector: {}
  numIoThreads: 8
  numNetworkThreads: 3
  numPartitions: 1
  numRecoveryThreadsPerDataDir: 1
  offsetsTopicReplicationFactor: 3
  pdb:
    create: false
    maxUnavailable: 1
  persistence:
    accessModes:
    - ReadWriteOnce
    annotations: {}
    enabled: true
    size: 8Gi
  podAnnotations: {}
  podLabels: {}
  podSecurityContext:
    fsGroup: 1001
    runAsUser: 1001
  priorityClassName: ""
  rbac:
    create: false
  readinessProbe:
    enabled: true
    failureThreshold: 6
    initialDelaySeconds: 5
    timeoutSeconds: 5
  replicaCount: 3
  resources:
    limits: {}
    requests: {}
  service:
    annotations: {}
    externalPort: 9094
    internalPort: 9093
    loadBalancerSourceRanges: []
    nodePorts:
      client: ""
      external: ""
    port: 9092
    type: ClusterIP
  serviceAccount:
    create: true
  sidecars: {}
  socketReceiveBufferBytes: 102400
  socketRequestMaxBytes: "50000000"
  socketSendBufferBytes: 102400
  tolerations: []
  transactionStateLogMinIsr: 3
  transactionStateLogReplicationFactor: 3
  updateStrategy: RollingUpdate
  volumePermissions:
    enabled: false
    image:
      pullPolicy: Always
      pullSecrets: []
      registry: docker.io
      repository: bitnami/minideb
      tag: buster
    resources:
      limits: {}
      requests: {}
  zookeeper:
    affinity: {}
    allowAnonymousLogin: true
    auth:
      clientPassword: null
      clientUser: null
      enabled: false
      serverPasswords: null
      serverUsers: null
    autopurge:
      purgeInterval: 0
      snapRetainCount: 3
    clusterDomain: cluster.local
    commonAnnotations: {}
    commonLabels: {}
    dataLogDir: ""
    enabled: true
    fourlwCommandsWhitelist: srvr, mntr, ruok
    global: {}
    heapSize: 1024
    image:
      debug: false
      pullPolicy: IfNotPresent
      registry: docker.io
      repository: bitnami/zookeeper
      tag: 3.6.2-debian-10-r58
    initLimit: 10
    listenOnAllIPs: false
    livenessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 30
      periodSeconds: 10
      probeCommandTimeout: 2
      successThreshold: 1
      timeoutSeconds: 5
    logLevel: ERROR
    maxClientCnxns: 60
    maxSessionTimeout: 40000
    metrics:
      containerPort: 9141
      enabled: false
      prometheusRule:
        enabled: false
        namespace: null
        rules: []
      service:
        annotations:
          prometheus.io/path: /metrics
          prometheus.io/port: '{{ .Values.metrics.service.port }}'
          prometheus.io/scrape: "true"
        port: 9141
        type: ClusterIP
      serviceMonitor:
        enabled: false
        namespace: null
    networkPolicy:
      enabled: false
    nodeSelector: {}
    persistence:
      accessModes:
      - ReadWriteOnce
      annotations: {}
      dataLogDir:
        size: 8Gi
      enabled: true
      size: 8Gi
    podAnnotations: {}
    podDisruptionBudget:
      maxUnavailable: 1
    podLabels: {}
    podManagementPolicy: Parallel
    priorityClassName: ""
    readinessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 5
      periodSeconds: 10
      probeCommandTimeout: 2
      successThreshold: 1
      timeoutSeconds: 5
    replicaCount: 1
    resources:
      requests:
        cpu: 250m
        memory: 256Mi
    securityContext:
      enabled: true
      fsGroup: 1001
      runAsUser: 1001
    service:
      annotations: {}
      electionPort: 3888
      followerPort: 2888
      headless:
        annotations: {}
      port: 2181
      publishNotReadyAddresses: true
      tls:
        client_enable: false
        client_keystore_password: ""
        client_keystore_path: /tls_key_store/key_store_file
        client_port: 3181
        client_truststore_password: ""
        client_truststore_path: /tls_trust_store/trust_store_file
        disable_base_client_port: false
        quorum_enable: false
        quorum_keystore_password: ""
        quorum_keystore_path: /tls_key_store/key_store_file
        quorum_truststore_password: ""
        quorum_truststore_path: /tls_trust_store/trust_store_file
      type: ClusterIP
    serviceAccount:
      create: false
    syncLimit: 5
    tickTime: 2000
    tolerations: []
    updateStrategy: RollingUpdate
    volumePermissions:
      enabled: false
      image:
        pullPolicy: Always
        registry: docker.io
        repository: bitnami/minideb
        tag: buster
      resources: {}
  zookeeperConnectionTimeoutMs: 6000
mail:
  backend: dummy
  from: ""
  host: ""
  password: ""
  port: 25
  useSsl: false
  useTls: false
  username: ""
metrics:
  affinity: {}
  enabled: false
  image:
    pullPolicy: IfNotPresent
    repository: prom/statsd-exporter
    tag: v0.17.0
  livenessProbe:
    enabled: true
    failureThreshold: 3
    initialDelaySeconds: 30
    periodSeconds: 5
    successThreshold: 1
    timeoutSeconds: 2
  nodeSelector: {}
  readinessProbe:
    enabled: true
    failureThreshold: 3
    initialDelaySeconds: 30
    periodSeconds: 5
    successThreshold: 1
    timeoutSeconds: 2
  resources: {}
  securityContext: {}
  service:
    labels: {}
    type: ClusterIP
  serviceMonitor:
    additionalLabels: {}
    enabled: false
    namespace: ""
    namespaceSelector: {}
    scrapeInterval: 30s
  tolerations: []
nginx:
  affinity: {}
  autoscaling:
    enabled: false
  cloneStaticSiteFromGit:
    enabled: false
    extraEnvVars: []
    extraVolumeMounts: []
    gitClone:
      args: null
      command: []
    gitSync:
      args: []
      command: []
    image:
      pullPolicy: IfNotPresent
      registry: docker.io
      repository: bitnami/git
      tag: 2.32.0-debian-10-r20
    interval: 60
  clusterDomain: cluster.local
  common:
    exampleValue: common-chart
    global: {}
  commonAnnotations: {}
  commonLabels: {}
  containerPort: 8080
  containerPorts:
    http: 8080
  containerSecurityContext:
    enabled: false
    runAsNonRoot: true
    runAsUser: 1001
  customLivenessProbe: {}
  customReadinessProbe: {}
  enabled: true
  existingServerBlockConfigmap: '{{ template "sentry.fullname" . }}'
  extraDeploy: []
  extraEnvVars: []
  extraVolumeMounts: []
  extraVolumes: []
  global: {}
  healthIngress:
    annotations: {}
    certManager: false
    enabled: false
    extraHosts: []
    extraTls: []
    hostname: example.local
    pathType: ImplementationSpecific
    secrets: []
    tls: false
  hostAliases: []
  image:
    debug: false
    pullPolicy: IfNotPresent
    pullSecrets: []
    registry: docker.io
    repository: bitnami/nginx
    tag: 1.21.0-debian-10-r21
  ingress:
    annotations: {}
    apiVersion: null
    certManager: false
    enabled: false
    hostname: nginx.local
    path: /
    pathType: ImplementationSpecific
    secrets: []
    tls: false
  ldapDaemon:
    customLivenessProbe: {}
    customReadinessProbe: {}
    enabled: false
    existingNginxServerBlockSecret: null
    image:
      pullPolicy: IfNotPresent
      registry: docker.io
      repository: bitnami/nginx-ldap-auth-daemon
      tag: 0.20200116.0-debian-10-r382
    ldapConfig:
      baseDN: ""
      bindDN: ""
      bindPassword: ""
      filter: ""
      httpCookieName: ""
      httpRealm: ""
      uri: ""
    livenessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 30
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    nginxServerBlock: |-
      server {
      listen 0.0.0.0:{{ .Values.containerPorts.http }};

      # You can provide a special subPath or the root
      location = / {
          auth_request /auth-proxy;
      }

      location = /auth-proxy {
          internal;

          proxy_pass http://127.0.0.1:{{ .Values.ldapDaemon.port }};

          ###############################################################
          # YOU SHOULD CHANGE THE FOLLOWING TO YOUR LDAP CONFIGURATION  #
          ###############################################################

          # URL and port for connecting to the LDAP server
          # proxy_set_header X-Ldap-URL "ldap://YOUR_LDAP_SERVER_IP:YOUR_LDAP_SERVER_PORT";

          # Base DN
          # proxy_set_header X-Ldap-BaseDN "dc=example,dc=org";

          # Bind DN
          # proxy_set_header X-Ldap-BindDN "cn=admin,dc=example,dc=org";

          # Bind password
          # proxy_set_header X-Ldap-BindPass "adminpassword";
      }
      }
    port: 8888
    readinessProbe:
      enabled: true
      failureThreshold: 3
      initialDelaySeconds: 5
      periodSeconds: 5
      successThreshold: 1
      timeoutSeconds: 3
  livenessProbe:
    enabled: true
    failureThreshold: 6
    initialDelaySeconds: 30
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 5
  metrics:
    enabled: false
    image:
      pullPolicy: IfNotPresent
      registry: docker.io
      repository: bitnami/nginx-exporter
      tag: 0.9.0-debian-10-r87
    podAnnotations: {}
    port: null
    resources:
      limits: {}
      requests: {}
    securityContext:
      enabled: false
      runAsUser: 1001
    service:
      annotations:
        prometheus.io/port: '{{ .Values.metrics.service.port }}'
        prometheus.io/scrape: "true"
      port: 9113
    serviceMonitor:
      enabled: false
  nodeAffinityPreset:
    key: ""
    type: ""
    values: []
  nodeSelector: {}
  pdb:
    create: false
    minAvailable: 1
  podAffinityPreset: ""
  podAnnotations: {}
  podAntiAffinityPreset: soft
  podLabels: {}
  podSecurityContext:
    enabled: false
    fsGroup: 1001
    sysctls: []
  priorityClassName: ""
  readinessProbe:
    enabled: true
    failureThreshold: 3
    initialDelaySeconds: 5
    periodSeconds: 5
    successThreshold: 1
    timeoutSeconds: 3
  replicaCount: 1
  resources:
    limits: {}
    requests: {}
  service:
    annotations: {}
    externalTrafficPolicy: Cluster
    httpsPort: 443
    nodePorts:
      http: ""
      https: ""
    port: 80
    targetPort:
      http: http
      https: https
    type: ClusterIP
  serviceAccount:
    annotations: {}
    create: false
  tolerations: {}
postgresql:
  audit:
    clientMinMessages: error
    logConnections: false
    logDisconnections: false
    logHostname: false
    logLinePrefix: ""
    logTimezone: ""
    pgAuditLog: ""
    pgAuditLogCatalog: "off"
  common:
    exampleValue: common-chart
    global:
      postgresql: {}
  commonAnnotations: {}
  containerSecurityContext:
    enabled: true
    runAsUser: 1001
  customLivenessProbe: {}
  customReadinessProbe: {}
  enabled: true
  extraDeploy: []
  extraEnv: []
  global:
    postgresql: {}
  image:
    debug: false
    pullPolicy: IfNotPresent
    registry: docker.io
    repository: bitnami/postgresql
    tag: 11.10.0-debian-10-r60
  ldap:
    baseDN: ""
    bind_password: null
    bindDN: ""
    enabled: false
    port: ""
    prefix: ""
    scheme: ""
    search_attr: ""
    search_filter: ""
    server: ""
    suffix: ""
    tls: {}
    url: ""
  livenessProbe:
    enabled: true
    failureThreshold: 6
    initialDelaySeconds: 30
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 5
  metrics:
    enabled: false
    extraEnvVars: {}
    image:
      pullPolicy: IfNotPresent
      registry: docker.io
      repository: bitnami/postgres-exporter
      tag: 0.8.0-debian-10-r328
    livenessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 5
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    prometheusRule:
      additionalLabels: {}
      enabled: false
      namespace: ""
      rules: []
    readinessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 5
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    securityContext:
      enabled: false
      runAsUser: 1001
    service:
      annotations:
        prometheus.io/port: "9187"
        prometheus.io/scrape: "true"
      loadBalancerIP: null
      type: ClusterIP
    serviceMonitor:
      additionalLabels: {}
      enabled: false
  nameOverride: sentry-postgresql
  networkPolicy:
    allowExternal: true
    enabled: false
    explicitNamespacesSelector: {}
  persistence:
    accessModes:
    - ReadWriteOnce
    annotations: {}
    enabled: true
    mountPath: /bitnami/postgresql
    selector: {}
    size: 8Gi
    subPath: ""
  postgresqlDataDir: /bitnami/postgresql/data
  postgresqlDatabase: sentry
  postgresqlSharedPreloadLibraries: pgaudit
  postgresqlUsername: postgres
  primary:
    affinity: {}
    annotations: {}
    extraInitContainers: []
    extraVolumeMounts: []
    extraVolumes: []
    labels: {}
    nodeAffinityPreset:
      key: ""
      type: ""
      values: []
    nodeSelector: {}
    podAffinityPreset: ""
    podAnnotations: {}
    podAntiAffinityPreset: soft
    podLabels: {}
    priorityClassName: ""
    service: {}
    sidecars: []
    tolerations: []
  primaryAsStandBy:
    enabled: false
  psp:
    create: false
  rbac:
    create: false
  readReplicas:
    affinity: {}
    annotations: {}
    extraInitContainers: []
    extraVolumeMounts: []
    extraVolumes: []
    labels: {}
    nodeAffinityPreset:
      key: ""
      type: ""
      values: []
    nodeSelector: {}
    persistence:
      enabled: true
    podAffinityPreset: ""
    podAnnotations: {}
    podAntiAffinityPreset: soft
    podLabels: {}
    priorityClassName: ""
    resources: {}
    service: {}
    sidecars: []
    tolerations: []
  readinessProbe:
    enabled: true
    failureThreshold: 6
    initialDelaySeconds: 5
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 5
  replication:
    applicationName: sentry
    enabled: false
    numSynchronousReplicas: 1
    password: repl_password
    readReplicas: 2
    synchronousCommit: "on"
    user: repl_user
  resources:
    requests:
      cpu: 250m
      memory: 256Mi
  securityContext:
    enabled: true
    fsGroup: 1001
  service:
    annotations: {}
    port: 5432
    type: ClusterIP
  serviceAccount:
    enabled: false
  shmVolume:
    chmod:
      enabled: true
    enabled: true
  tls:
    certCAFilename: null
    certFilename: ""
    certKeyFilename: ""
    certificatesSecret: ""
    crlFilename: null
    enabled: false
    preferServerCiphers: true
  updateStrategy:
    type: RollingUpdate
  volumePermissions:
    enabled: false
    image:
      pullPolicy: Always
      registry: docker.io
      repository: bitnami/minideb
      tag: buster
    securityContext:
      runAsUser: 0
prefix: null
rabbitmq:
  advancedConfiguration: ""
  affinity: {}
  auth:
    erlangCookie: pHgpy3Q6adTskzAT6bLHCFqFTF7lMxhA
    password: guest
    tls:
      caCertificate: ""
      enabled: false
      existingSecretFullChain: false
      failIfNoPeerCert: true
      serverCertificate: ""
      serverKey: ""
      sslOptionsVerify: verify_peer
    username: guest
  clusterDomain: cluster.local
  clustering:
    addressType: hostname
    forceBoot: true
    rebalance: true
  common:
    exampleValue: common-chart
    global: {}
  configuration: |-
    ## Username and password
    ##
    default_user = {{ .Values.auth.username }}
    default_pass = CHANGEME
    ## Clustering
    ##
    cluster_formation.peer_discovery_backend  = rabbit_peer_discovery_k8s
    cluster_formation.k8s.host = kubernetes.default.svc.{{ .Values.clusterDomain }}
    cluster_formation.node_cleanup.interval = 10
    cluster_formation.node_cleanup.only_log_warning = true
    cluster_partition_handling = autoheal
    # queue master locator
    queue_master_locator = min-masters
    # enable guest user
    loopback_users.guest = false
    {{ tpl .Values.extraConfiguration . }}
    {{- if .Values.auth.tls.enabled }}
    ssl_options.verify = {{ .Values.auth.tls.sslOptionsVerify }}
    listeners.ssl.default = {{ .Values.service.tlsPort }}
    ssl_options.fail_if_no_peer_cert = {{ .Values.auth.tls.failIfNoPeerCert }}
    ssl_options.cacertfile = /opt/bitnami/rabbitmq/certs/ca_certificate.pem
    ssl_options.certfile = /opt/bitnami/rabbitmq/certs/server_certificate.pem
    ssl_options.keyfile = /opt/bitnami/rabbitmq/certs/server_key.pem
    {{- end }}
    {{- if .Values.ldap.enabled }}
    auth_backends.1 = rabbit_auth_backend_ldap
    auth_backends.2 = internal
    {{- range $index, $server := .Values.ldap.servers }}
    auth_ldap.servers.{{ add $index 1 }} = {{ $server }}
    {{- end }}
    auth_ldap.port = {{ .Values.ldap.port }}
    auth_ldap.user_dn_pattern = {{ .Values.ldap.user_dn_pattern  }}
    {{- if .Values.ldap.tls.enabled }}
    auth_ldap.use_ssl = true
    {{- end }}
    {{- end }}
    {{- if .Values.metrics.enabled }}
    ## Prometheus metrics
    ##
    prometheus.tcp.port = 9419
    {{- end }}
    {{- if .Values.memoryHighWatermark.enabled }}
    ## Memory Threshold
    ##
    total_memory_available_override_value = {{ include "rabbitmq.toBytes" .Values.resources.limits.memory }}
    vm_memory_high_watermark.{{ .Values.memoryHighWatermark.type }} = {{ .Values.memoryHighWatermark.value }}
    {{- end }}
  containerSecurityContext: {}
  customLivenessProbe: {}
  customReadinessProbe: {}
  customStartupProbe: {}
  enabled: true
  extraConfiguration: |
    load_definitions = /app/load_definition.json
  extraContainerPorts: []
  extraEnvVars: []
  extraPlugins: rabbitmq_auth_backend_ldap
  extraSecrets:
    load-definition:
      load_definition.json: |
        {
          "users": [
            {
              "name": "{{ .Values.auth.username }}",
              "password": "{{ .Values.auth.password }}",
              "tags": "administrator"
            }
          ],
          "permissions": [{
            "user": "{{ .Values.auth.username }}",
            "vhost": "/",
            "configure": ".*",
            "write": ".*",
            "read": ".*"
          }],
          "policies": [
            {
              "name": "ha-all",
              "pattern": ".*",
              "vhost": "/",
              "definition": {
                "ha-mode": "all",
                "ha-sync-mode": "automatic",
                "ha-sync-batch-size": 1
              }
            }
          ],
          "vhosts": [
            {
              "name": "/"
            }
          ]
        }
  extraSecretsPrependReleaseName: false
  extraVolumeMounts: []
  extraVolumes: []
  global: {}
  hostAliases: []
  image:
    debug: false
    pullPolicy: IfNotPresent
    registry: docker.io
    repository: bitnami/rabbitmq
    tag: 3.8.11-debian-10-r0
  ingress:
    annotations: {}
    certManager: false
    enabled: false
    hostname: rabbitmq.local
    path: /
    pathType: ImplementationSpecific
    secrets: []
    tls: false
  initContainers: {}
  ldap:
    enabled: false
    port: "389"
    servers: []
    tls:
      enabled: false
    user_dn_pattern: cn=${username},dc=example,dc=org
  livenessProbe:
    enabled: true
    failureThreshold: 6
    initialDelaySeconds: 120
    periodSeconds: 30
    successThreshold: 1
    timeoutSeconds: 20
  loadDefinition:
    enabled: true
    existingSecret: load-definition
  logs: '-'
  memoryHighWatermark:
    enabled: false
    type: relative
    value: 0.4
  metrics:
    enabled: false
    plugins: rabbitmq_prometheus
    podAnnotations:
      prometheus.io/port: '{{ .Values.service.metricsPort }}'
      prometheus.io/scrape: "true"
    prometheusRule:
      additionalLabels: {}
      enabled: false
      namespace: ""
      rules: []
    serviceMonitor:
      additionalLabels: {}
      enabled: false
      honorLabels: false
      interval: 30s
  nameOverride: ""
  networkPolicy:
    allowExternal: true
    enabled: false
  nodeAffinityPreset:
    key: ""
    type: ""
    values: []
  nodeSelector: {}
  pdb:
    create: true
    minAvailable: 1
  persistence:
    accessMode: ReadWriteOnce
    enabled: true
    selector: {}
    size: 8Gi
    volumes: null
  plugins: rabbitmq_management rabbitmq_peer_discovery_k8s
  podAffinityPreset: ""
  podAnnotations: {}
  podAntiAffinityPreset: soft
  podLabels: {}
  podManagementPolicy: OrderedReady
  podSecurityContext:
    enabled: true
    fsGroup: 1001
    runAsUser: 1001
  priorityClassName: ""
  rbac:
    create: true
  readinessProbe:
    enabled: true
    failureThreshold: 3
    initialDelaySeconds: 10
    periodSeconds: 30
    successThreshold: 1
    timeoutSeconds: 20
  replicaCount: 3
  resources:
    limits: {}
    requests: {}
  service:
    annotations: {}
    distPort: 25672
    distPortName: dist
    epmdPortName: epmd
    externalTrafficPolicy: Cluster
    extraPorts: []
    labels: {}
    managerPort: 15672
    managerPortName: http-stats
    metricsPort: 9419
    metricsPortName: metrics
    port: 5672
    portName: amqp
    tlsPort: 5671
    tlsPortName: amqp-ssl
    type: ClusterIP
  serviceAccount:
    create: true
  sidecars: {}
  statefulsetLabels: {}
  terminationGracePeriodSeconds: 120
  tolerations: []
  ulimitNofiles: "65536"
  updateStrategyType: RollingUpdate
  volumePermissions:
    enabled: false
    image:
      pullPolicy: Always
      pullSecrets: []
      registry: docker.io
      repository: bitnami/minideb
      tag: buster
    resources:
      limits: {}
      requests: {}
redis:
  architecture: standalone
  auth:
    enabled: false
    existingSecret: ""
    existingSecretPasswordKey: ""
    password: ""
    sentinel: false
    usePasswordFiles: false
  clusterDomain: cluster.local
  common:
    exampleValue: common-chart
    global:
      imagePullSecrets: []
      imageRegistry: ""
      redis:
        password: ""
      storageClass: ""
  commonAnnotations: {}
  commonConfiguration: |-
    # Enable AOF https://redis.io/topics/persistence#append-only-file
    appendonly yes
    # Disable RDB persistence, AOF persistence already enabled.
    save ""
  commonLabels: {}
  diagnosticMode:
    args:
    - infinity
    command:
    - sleep
    enabled: false
  enabled: true
  existingConfigmap: ""
  extraDeploy: []
  fullnameOverride: ""
  global:
    imagePullSecrets: []
    imageRegistry: ""
    redis:
      password: ""
    storageClass: ""
  image:
    debug: false
    pullPolicy: IfNotPresent
    pullSecrets: []
    registry: docker.io
    repository: bitnami/redis
    tag: 6.2.5-debian-10-r34
  kubeVersion: ""
  master:
    affinity: {}
    args: []
    command: []
    configuration: ""
    containerPort: 6379
    containerSecurityContext:
      enabled: true
      runAsUser: 1001
    customLivenessProbe: {}
    customReadinessProbe: {}
    disableCommands:
    - FLUSHDB
    - FLUSHALL
    extraEnvVars: []
    extraEnvVarsCM: ""
    extraEnvVarsSecret: ""
    extraFlags: []
    extraVolumeMounts: []
    extraVolumes: []
    hostAliases: []
    initContainers: []
    lifecycleHooks: {}
    livenessProbe:
      enabled: true
      failureThreshold: 5
      initialDelaySeconds: 20
      periodSeconds: 5
      successThreshold: 1
      timeoutSeconds: 5
    nodeAffinityPreset:
      key: ""
      type: ""
      values: []
    nodeSelector: {}
    persistence:
      accessModes:
      - ReadWriteOnce
      annotations: {}
      enabled: true
      existingClaim: ""
      path: /data
      selector: {}
      size: 8Gi
      storageClass: ""
      subPath: ""
    podAffinityPreset: ""
    podAnnotations: {}
    podAntiAffinityPreset: soft
    podLabels: {}
    podSecurityContext:
      enabled: true
      fsGroup: 1001
    preExecCmds: []
    priorityClassName: ""
    readinessProbe:
      enabled: true
      failureThreshold: 5
      initialDelaySeconds: 20
      periodSeconds: 5
      successThreshold: 1
      timeoutSeconds: 1
    resources:
      limits: {}
      requests: {}
    schedulerName: ""
    service:
      annotations: {}
      clusterIP: ""
      externalTrafficPolicy: Cluster
      loadBalancerIP: ""
      loadBalancerSourceRanges: []
      nodePort: ""
      port: 6379
      type: ClusterIP
    shareProcessNamespace: false
    sidecars: []
    spreadConstraints: {}
    terminationGracePeriodSeconds: 30
    tolerations: []
    updateStrategy:
      rollingUpdate: {}
      type: RollingUpdate
  metrics:
    containerSecurityContext:
      enabled: true
      runAsUser: 1001
    enabled: false
    extraArgs: {}
    extraVolumeMounts: []
    extraVolumes: []
    image:
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/redis-exporter
      tag: 1.26.0-debian-10-r5
    podAnnotations:
      prometheus.io/port: "9121"
      prometheus.io/scrape: "true"
    podLabels: {}
    prometheusRule:
      additionalLabels: {}
      enabled: false
      namespace: ""
      rules: []
    redisTargetHost: localhost
    resources:
      limits: {}
      requests: {}
    service:
      annotations: {}
      externalTrafficPolicy: Cluster
      loadBalancerIP: ""
      loadBalancerSourceRanges: []
      port: 9121
      type: ClusterIP
    serviceMonitor:
      additionalLabels: {}
      enabled: false
      honorLabels: false
      interval: 30s
      metricRelabelings: []
      namespace: ""
      relabellings: []
      scrapeTimeout: ""
  nameOverride: sentry-redis
  networkPolicy:
    allowExternal: true
    enabled: false
    extraEgress: []
    extraIngress: []
    ingressNSMatchLabels: {}
    ingressNSPodMatchLabels: {}
  pdb:
    create: false
    maxUnavailable: ""
    minAvailable: 1
  podSecurityPolicy:
    create: false
    enabled: false
  rbac:
    create: false
    rules: []
  replica:
    affinity: {}
    args: []
    autoscaling:
      enabled: false
      maxReplicas: 11
      minReplicas: 1
      targetCPU: ""
      targetMemory: ""
    command: []
    configuration: ""
    containerPort: 6379
    containerSecurityContext:
      enabled: true
      runAsUser: 1001
    customLivenessProbe: {}
    customReadinessProbe: {}
    disableCommands:
    - FLUSHDB
    - FLUSHALL
    extraEnvVars: []
    extraEnvVarsCM: ""
    extraEnvVarsSecret: ""
    extraFlags: []
    extraVolumeMounts: []
    extraVolumes: []
    hostAliases: []
    initContainers: []
    lifecycleHooks: {}
    livenessProbe:
      enabled: true
      failureThreshold: 5
      initialDelaySeconds: 20
      periodSeconds: 5
      successThreshold: 1
      timeoutSeconds: 5
    nodeAffinityPreset:
      key: ""
      type: ""
      values: []
    nodeSelector: {}
    persistence:
      accessModes:
      - ReadWriteOnce
      annotations: {}
      enabled: true
      path: /data
      selector: {}
      size: 8Gi
      storageClass: ""
      subPath: ""
    podAffinityPreset: ""
    podAnnotations: {}
    podAntiAffinityPreset: soft
    podLabels: {}
    podSecurityContext:
      enabled: true
      fsGroup: 1001
    preExecCmds: []
    priorityClassName: ""
    readinessProbe:
      enabled: true
      failureThreshold: 5
      initialDelaySeconds: 20
      periodSeconds: 5
      successThreshold: 1
      timeoutSeconds: 1
    replicaCount: 3
    resources:
      limits: {}
      requests: {}
    schedulerName: ""
    service:
      annotations: {}
      clusterIP: ""
      externalTrafficPolicy: Cluster
      loadBalancerIP: ""
      loadBalancerSourceRanges: []
      nodePort: ""
      port: 6379
      type: ClusterIP
    shareProcessNamespace: false
    sidecars: []
    spreadConstraints: {}
    terminationGracePeriodSeconds: 30
    tolerations: []
    updateStrategy:
      rollingUpdate: {}
      type: RollingUpdate
  sentinel:
    args: []
    command: []
    configuration: ""
    containerPort: 26379
    containerSecurityContext:
      enabled: true
      runAsUser: 1001
    customLivenessProbe: {}
    customReadinessProbe: {}
    downAfterMilliseconds: 60000
    enabled: false
    extraEnvVars: []
    extraEnvVarsCM: ""
    extraEnvVarsSecret: ""
    extraVolumeMounts: []
    extraVolumes: []
    failoverTimeout: 18000
    image:
      debug: false
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/redis-sentinel
      tag: 6.2.5-debian-10-r34
    lifecycleHooks: {}
    livenessProbe:
      enabled: true
      failureThreshold: 5
      initialDelaySeconds: 20
      periodSeconds: 5
      successThreshold: 1
      timeoutSeconds: 5
    masterSet: mymaster
    parallelSyncs: 1
    preExecCmds: []
    quorum: 2
    readinessProbe:
      enabled: true
      failureThreshold: 5
      initialDelaySeconds: 20
      periodSeconds: 5
      successThreshold: 1
      timeoutSeconds: 1
    resources:
      limits: {}
      requests: {}
    service:
      annotations: {}
      clusterIP: ""
      externalTrafficPolicy: Cluster
      loadBalancerIP: ""
      loadBalancerSourceRanges: []
      nodePorts:
        redis: ""
        sentinel: ""
      port: 6379
      sentinelPort: 26379
      type: ClusterIP
    terminationGracePeriodSeconds: 30
  serviceAccount:
    annotations: {}
    automountServiceAccountToken: true
    create: true
    name: ""
  sysctl:
    command: []
    enabled: false
    image:
      pullPolicy: Always
      pullSecrets: []
      registry: docker.io
      repository: bitnami/bitnami-shell
      tag: 10-debian-10-r174
    mountHostSys: false
    resources:
      limits: {}
      requests: {}
  tls:
    authClients: true
    autoGenerated: false
    certCAFilename: ""
    certFilename: ""
    certKeyFilename: ""
    certificatesSecret: ""
    dhParamsFilename: ""
    enabled: false
    existingSecret: ""
  usePassword: false
  volumePermissions:
    containerSecurityContext:
      runAsUser: 0
    enabled: false
    image:
      pullPolicy: Always
      pullSecrets: []
      registry: docker.io
      repository: bitnami/bitnami-shell
      tag: 10-debian-10-r174
    resources:
      limits: {}
      requests: {}
relay:
  affinity: {}
  autoscaling:
    enabled: false
    maxReplicas: 5
    minReplicas: 2
    targetCPUUtilizationPercentage: 50
  env: []
  mode: managed
  nodeSelector: {}
  probeFailureThreshold: 5
  probeInitialDelaySeconds: 10
  probePeriodSeconds: 10
  probeSuccessThreshold: 1
  probeTimeoutSeconds: 2
  replicas: 1
  resources: {}
  securityContext: {}
  service:
    annotations: {}
  sidecars: []
  volumes: []
revisionHistoryLimit: 10
sentry:
  cleanup:
    concurrencyPolicy: Allow
    days: 90
    enabled: true
    schedule: 0 0 * * *
    sidecars: []
    volumes: []
  cron:
    affinity: {}
    env: []
    nodeSelector: {}
    replicas: 1
    resources: {}
    sidecars: []
    volumes: []
  features:
    orgSubdomains: false
    vstsLimitedScopes: true
  ingestConsumer:
    affinity: {}
    autoscaling:
      enabled: false
      maxReplicas: 3
      minReplicas: 1
      targetCPUUtilizationPercentage: 50
    env: []
    nodeSelector: {}
    replicas: 1
    resources: {}
    securityContext: {}
    sidecars: []
    volumes: []
  postProcessForward:
    affinity: {}
    env: []
    nodeSelector: {}
    replicas: 1
    resources: {}
    securityContext: {}
    sidecars: []
    volumes: []
  singleOrganization: true
  subscriptionConsumerEvents:
    affinity: {}
    env: []
    nodeSelector: {}
    replicas: 1
    resources: {}
    securityContext: {}
    sidecars: []
    volumes: []
  subscriptionConsumerTransactions:
    affinity: {}
    env: []
    nodeSelector: {}
    replicas: 1
    resources: {}
    securityContext: {}
    sidecars: []
    volumes: []
  web:
    affinity: {}
    autoscaling:
      enabled: false
      maxReplicas: 5
      minReplicas: 2
      targetCPUUtilizationPercentage: 50
    env: []
    nodeSelector: {}
    probeFailureThreshold: 5
    probeInitialDelaySeconds: 10
    probePeriodSeconds: 10
    probeSuccessThreshold: 1
    probeTimeoutSeconds: 2
    replicas: 1
    resources: {}
    securityContext: {}
    service:
      annotations: {}
    sidecars: []
    strategyType: RollingUpdate
    volumes: []
  worker:
    affinity: {}
    autoscaling:
      enabled: false
      maxReplicas: 5
      minReplicas: 2
      targetCPUUtilizationPercentage: 50
    env: []
    livenessProbe:
      enabled: false
      failureThreshold: 3
      periodSeconds: 60
      timeoutSeconds: 10
    nodeSelector: {}
    replicas: 3
    resources: {}
    sidecars: []
    volumes: []
service:
  annotations: {}
  externalPort: 9000
  name: sentry
  type: ClusterIP
serviceAccount:
  annotations: {}
  automountServiceAccountToken: true
  enabled: false
  name: sentry
slack: {}
snuba:
  api:
    affinity: {}
    autoscaling:
      enabled: false
      maxReplicas: 5
      minReplicas: 2
      targetCPUUtilizationPercentage: 50
    command: {}
    env: []
    liveness:
      timeoutSeconds: 2
    nodeSelector: {}
    probeInitialDelaySeconds: 10
    readiness:
      timeoutSeconds: 2
    replicas: 1
    resources: {}
    securityContext: {}
    service:
      annotations: {}
    sidecars: []
    volumes: []
  cleanupErrors:
    concurrencyPolicy: Allow
    enabled: true
    schedule: 0 * * * *
    sidecars: []
    volumes: []
  cleanupTransactions:
    concurrencyPolicy: Allow
    enabled: true
    schedule: 0 * * * *
    sidecars: []
    volumes: []
  consumer:
    affinity: {}
    autoOffsetReset: earliest
    env: []
    nodeSelector: {}
    replicas: 1
    resources: {}
    securityContext: {}
  dbInitJob:
    env: []
  migrateJob:
    env: []
  outcomesConsumer:
    affinity: {}
    autoOffsetReset: earliest
    env: []
    maxBatchSize: "3"
    nodeSelector: {}
    replicas: 1
    resources: {}
    securityContext: {}
  replacer:
    affinity: {}
    autoOffsetReset: earliest
    env: []
    maxBatchSize: "3"
    nodeSelector: {}
    replicas: 1
    resources: {}
    securityContext: {}
  sessionsConsumer:
    affinity: {}
    autoOffsetReset: earliest
    env: []
    nodeSelector: {}
    replicas: 1
    resources: {}
    securityContext: {}
  subscriptionConsumerEvents:
    affinity: {}
    autoOffsetReset: earliest
    env: []
    nodeSelector: {}
    replicas: 1
    resources: {}
    securityContext: {}
  subscriptionConsumerTransactions:
    affinity: {}
    autoOffsetReset: earliest
    env: []
    nodeSelector: {}
    replicas: 1
    resources: {}
    securityContext: {}
  transactionsConsumer:
    affinity: {}
    autoOffsetReset: earliest
    env: []
    nodeSelector: {}
    replicas: 1
    resources: {}
    securityContext: {}
symbolicator:
  api:
    affinity: {}
    autoscaling:
      enabled: false
      maxReplicas: 5
      minReplicas: 2
      targetCPUUtilizationPercentage: 50
    config: |-
      # See: https://getsentry.github.io/symbolicator/#configuration
      cache_dir: "/data"
      bind: "0.0.0.0:3021"
      logging:
        level: "warn"
      metrics:
        statsd: null
        prefix: "symbolicator"
      sentry_dsn: null
      connect_to_reserved_ips: true
      # caches:
      #   downloaded:
      #     max_unused_for: 1w
      #     retry_misses_after: 5m
      #     retry_malformed_after: 5m
      #   derived:
      #     max_unused_for: 1w
      #     retry_misses_after: 5m
      #     retry_malformed_after: 5m
      #   diagnostics:
      #     retention: 1w
    env: []
    nodeSelector: {}
    probeInitialDelaySeconds: 10
    replicas: 1
    resources: {}
    securityContext: {}
  cleanup:
    enabled: false
  enabled: false
system:
  adminEmail: ""
  public: false
  url: ""
user:
  create: true
  email: admin@sentry.local
  password: aaaa
zookeeper:
  affinity: {}
  args: []
  auth:
    clientPassword: ""
    clientUser: ""
    enabled: false
    existingSecret: ""
    serverPasswords: ""
    serverUsers: ""
  autopurge:
    purgeInterval: 0
    snapRetainCount: 3
  clusterDomain: cluster.local
  command:
  - /scripts/setup.sh
  common:
    exampleValue: common-chart
    global:
      imagePullSecrets: []
      imageRegistry: ""
      storageClass: ""
  commonAnnotations: {}
  commonLabels: {}
  configuration: ""
  containerPorts:
    client: 2181
    election: 3888
    follower: 2888
    tls: 3181
  containerSecurityContext:
    enabled: true
    runAsNonRoot: true
    runAsUser: 1001
  customLivenessProbe: {}
  customReadinessProbe: {}
  customStartupProbe: {}
  dataLogDir: ""
  diagnosticMode:
    args:
    - infinity
    command:
    - sleep
    enabled: false
  enabled: true
  existingConfigmap: ""
  extraDeploy: []
  extraEnvVars: []
  extraEnvVarsCM: ""
  extraEnvVarsSecret: ""
  extraVolumeMounts: []
  extraVolumes: []
  fourlwCommandsWhitelist: srvr, mntr, ruok
  fullnameOverride: ""
  global:
    imagePullSecrets: []
    imageRegistry: ""
    storageClass: ""
  heapSize: 1024
  hostAliases: []
  image:
    debug: false
    pullPolicy: IfNotPresent
    pullSecrets: []
    registry: docker.io
    repository: bitnami/zookeeper
    tag: 3.8.0-debian-10-r0
  initContainers: []
  initLimit: 10
  jvmFlags: ""
  kubeVersion: ""
  lifecycleHooks: {}
  listenOnAllIPs: false
  livenessProbe:
    enabled: true
    failureThreshold: 6
    initialDelaySeconds: 30
    periodSeconds: 10
    probeCommandTimeout: 2
    successThreshold: 1
    timeoutSeconds: 5
  logLevel: ERROR
  maxClientCnxns: 60
  maxSessionTimeout: 40000
  metrics:
    containerPort: 9141
    enabled: false
    prometheusRule:
      additionalLabels: {}
      enabled: false
      namespace: ""
      rules: []
    service:
      annotations:
        prometheus.io/path: /metrics
        prometheus.io/port: '{{ .Values.metrics.service.port }}'
        prometheus.io/scrape: "true"
      port: 9141
      type: ClusterIP
    serviceMonitor:
      additionalLabels: {}
      enabled: false
      honorLabels: false
      interval: ""
      jobLabel: ""
      metricRelabelings: []
      namespace: ""
      relabelings: []
      scrapeTimeout: ""
      selector: {}
  minServerId: 1
  nameOverride: zookeeper-clickhouse
  namespaceOverride: ""
  networkPolicy:
    allowExternal: true
    enabled: false
  nodeAffinityPreset:
    key: ""
    type: ""
    values: []
  nodeSelector: {}
  pdb:
    create: false
    maxUnavailable: 1
    minAvailable: ""
  persistence:
    accessModes:
    - ReadWriteOnce
    annotations: {}
    dataLogDir:
      existingClaim: ""
      selector: {}
      size: 8Gi
    enabled: true
    existingClaim: ""
    selector: {}
    size: 8Gi
    storageClass: ""
  podAffinityPreset: ""
  podAnnotations: {}
  podAntiAffinityPreset: soft
  podLabels: {}
  podManagementPolicy: Parallel
  podSecurityContext:
    enabled: true
    fsGroup: 1001
  preAllocSize: 65536
  priorityClassName: ""
  readinessProbe:
    enabled: true
    failureThreshold: 6
    initialDelaySeconds: 5
    periodSeconds: 10
    probeCommandTimeout: 2
    successThreshold: 1
    timeoutSeconds: 5
  replicaCount: 3
  resources:
    limits: {}
    requests:
      cpu: 250m
      memory: 256Mi
  schedulerName: ""
  service:
    annotations: {}
    clusterIP: ""
    disableBaseClientPort: false
    externalTrafficPolicy: Cluster
    extraPorts: []
    headless:
      annotations: {}
      publishNotReadyAddresses: true
    loadBalancerIP: ""
    loadBalancerSourceRanges: []
    nodePorts:
      client: ""
      tls: ""
    ports:
      client: 2181
      election: 3888
      follower: 2888
      tls: 3181
    sessionAffinity: None
    type: ClusterIP
  serviceAccount:
    annotations: {}
    automountServiceAccountToken: true
    create: false
    name: ""
  sidecars: []
  snapCount: 100000
  startupProbe:
    enabled: false
    failureThreshold: 15
    initialDelaySeconds: 30
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 1
  syncLimit: 5
  tickTime: 2000
  tls:
    client:
      autoGenerated: false
      enabled: false
      existingSecret: ""
      keystorePassword: ""
      keystorePath: /opt/bitnami/zookeeper/config/certs/client/zookeeper.keystore.jks
      passwordsSecretName: ""
      truststorePassword: ""
      truststorePath: /opt/bitnami/zookeeper/config/certs/client/zookeeper.truststore.jks
    quorum:
      autoGenerated: false
      enabled: false
      existingSecret: ""
      keystorePassword: ""
      keystorePath: /opt/bitnami/zookeeper/config/certs/quorum/zookeeper.keystore.jks
      passwordsSecretName: ""
      truststorePassword: ""
      truststorePath: /opt/bitnami/zookeeper/config/certs/quorum/zookeeper.truststore.jks
    resources:
      limits: {}
      requests: {}
  tolerations: []
  topologySpreadConstraints: {}
  updateStrategy:
    rollingUpdate: {}
    type: RollingUpdate
  volumePermissions:
    containerSecurityContext:
      runAsUser: 0
    enabled: false
    image:
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/bitnami-shell
      tag: 10-debian-10-r368
    resources:
      limits: {}
      requests: {}